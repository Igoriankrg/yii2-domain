Архитектура
========

В проекте используется архитектура MVC.
 
* M - модель
* V - вид
* C - контроллер

## Модель

Понятие модели в данном проекте - это не Active Record в чистом виде.
Под моделью подразумевается архитектура пардигмы DDD (Domain-driven design).

DDD-модель имеет слои:

* Домен
* Сервис
* Хранилище (репозиторий)
* Сущность

## Вид

Вид принимает данные от контроллера и форматирует как нужно и выводит пользователю.
Обеспечивает интерфейс пользователя.

## Контроллер

Контроллер 

* собирает данные из окружения
* принимает параметры GET, POST и передает их куда требуется
* взаимодействует сервисами (DDD)
* взимодействует с видом

АПИ контроллер имеет те же пункты, кроме вида. 
Вид заменяется сериализатором данных.

## Структура обработки запроса

Структура:

* клиент делает запрос
* роутер направляет клиента на контроллер
* контроллер
    * собирает данные запроса
    * вызывает метод сервиса
    * сервис
        * проводит аутентификацию
        * обратывает параметры
        * берет данные из репозиториев (хранилищ)
        * репозиторий
            * формирует запрос
            * получает данные
            * возвращает сущность/коллекцию, либо исключение
        * обрабатывает данные
        * возвращает сущность/коллекцию, либо исключение
    * получает данные из сервиса
    * обрабатывает исключения, если они есть
    * передает данные в представление
    * представление
        * определяет формат вывода
        * формирует контент
        * возвращает контент
    * получает контент из представления
    * отдает контент клиенту
* клиент получает ответ

Цепочка запроса:

    пользователь->роутер->контроллер->сервис->репозиторий->БД
    
Цепочка ответа:

    пользователь<-представление<-контроллер<-сервис<-репозиторий<-БД

## Именование методов

Когда требуется получить некий список фильтруя по опреденному полю,
можно создать метод в репозитории allByStatus($status, Query $query).
Если этот метод необходим не только в сервисах, 
то можно отзеркалить его в сервисе.

Не забывайте покрывать методы хранилищ и сервисов интерфейсами.
Это позволит прозрачно создавать драйвера хранилищ
и альтернативные сервисы (прокси, кеш).
